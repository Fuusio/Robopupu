/*
 * Copyright (C) 2014 - 2015 Marko Salmela, http://robopupu.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.robopupu.api.dependency;

import android.util.Log;

import com.robopupu.api.plugin.PluginBus;
import com.robopupu.api.util.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * {@link DependencyScope} provides an abstract base class for implementing objects that provide
 * and cache a scoped dependencies. An instance of a concrete implementation of {@link DependencyScope}
 * is not used directly to access dependencies, but via the static methods of class {@link Dependency}
 * (or convenience class {@link D}).
 */
public abstract class DependencyScope {

    private static final String TAG = Utils.tag(DependencyScope.class);

    /*
     * A cache of dependants that have request dependencies. These dependants are temporarily
     * cached because they can also be dependencies for other objects.
     */
    protected final ArrayList<Object> dependants;

    /*
     * A cache of created and provided dependencies.
     */
    protected final HashMap<Class<?>, ArrayList<Object>> dependencies;

    /**
     * A reference to an optional overriding {@link DependencyScope} used providing mock dependencies.
     */
    protected DependencyScope mockScope;

    /*
     * The {@link DependencyScopeOwner} that owns this {@link DependencyScope} and manages its
     * lifecycle.
     */
    private DependencyScopeOwner owner;

    /*
     * A reference to an optional parent {@link DependencyScope}.
     */
    protected DependencyScope parentScope;

    /*
     * A {@link DependencyProvider} that is either code generated by the annotation processor of Fuusio
     * API Compiler or explicitly created by method {@link DependencyScope#createDependencyProvider()}.
     */
    protected DependencyProvider dependencyProvider;

    /*
     * A {@code boolean} flag indicating whether this {@link DependencyScope} has been initialised.
     * Initialisation creates an instance of {@link DependencyProvider}.
     */
    protected boolean initialized;

    /*
     * A helper field for storing the currently requested type of dependency.
     */
    private Class<?> dependencyType;

    protected DependencyScope() {
        dependencies = new HashMap<>();
        dependants = new ArrayList<>();
        initialized = false;
    }

    /**
     * Gets the {@link DependencyProvider}. A {@link DependencyProvider} is either code generated
     * by the annotation processor of Fuusio API Compiler or explicitly created by method
     * {@link DependencyScope#createDependencyProvider()}.
     *
     * @return A {@link DependencyProvider}. May return {@code null}.
     */
    protected DependencyProvider getDependencyProvider() {
        if (dependencyProvider == null) {
            if (!initialized) {
                initialize();
            }
        }
        return dependencyProvider;
    }

    /**
     * Gets the identifier of this {@link DependencyScope}. The default identifier is the canonical
     * class name of the {@link DependencyScope}.
     *
     * @return The identifier as a {@link String}.
     */
    public String getId() {
        return getClass().getCanonicalName();
    }

    /**
     * Get the {@link DependencyScopeOwner} that manages the lifecycle this {@link DependencyScope}.
     *
     * @return A {@link DependencyScopeOwner}.
     */
    public final DependencyScopeOwner getOwner() {
        return owner;
    }

    /**
     * Set the {@link DependencyScopeOwner} that manages the lifecycle this {@link DependencyScope}.
     *
     * @param owner A {@link DependencyScopeOwner}.
     */
    public void setOwner(final DependencyScopeOwner owner) {
        this.owner = owner;
    }

    /**
     * Gets the parent {@link DependencyScope}.
     *
     * @return A {@link DependencyScope}. May return {@code null} if the parent is not set.
     */
    @SuppressWarnings("unused")
    public final DependencyScope getParentScope() {
        return parentScope;
    }

    /**
     * Sets the parent {@link DependencyScope}.
     *
     * @param parent A {@link DependencyScope}. May be {@code null}.
     */
    public void setParentScope(final DependencyScope parent) {
        parentScope = parent;
    }

    /**
     * Gets the {@link DependencyScope} that overrides this {@link DependencyScope}. An overriding
     * {@link DependencyScope} can be used for providing mock dependencies for unit tests.
     *
     * @return A {@link DependencyScope}. May return {@code null}.
     */
    @SuppressWarnings("unused")
    public final DependencyScope getMockedScope() {
        return mockScope;
    }

    /**
     * Sets the given {@link DependencyScope} to override this {@link DependencyScope}. An overriding
     * {@link DependencyScope} can be used for providing mock dependencies for unit tests.
     *
     * @param scope A {@link DependencyScope}.
     */
    @SuppressWarnings("unused")
    public void setMockedScope(final DependencyScope scope) {
        mockScope = scope;
    }

    /**
     * Tests if this {@link DependencyScope} can be disposed.
     *
     * @return A {@code boolean} value.
     */
    public boolean isDisposable() {
        return true;
    }

    /**
     * Adds the given {@link Object} as a dependant to this {@link DependencyScope}.
     *
     * @param dependant An {@link Object}.
     */
    protected void addDependant(final Object dependant) {
        dependants.add(dependant);
    }

    /**
     * Tests if the specified type represents the requested dependency type.
     *
     * @param dependencyType A {@link Class} specifying the type of the requested dependency.
     * @return A {@code boolean} value.
     */
    @SuppressWarnings("unchecked")
    protected final boolean type(final Class<?> dependencyType) {
        return this.dependencyType.isAssignableFrom(dependencyType);
    }

    /**
     * Caches the requested dependency {@link Object} before it is returned to a requester.
     *
     * @param dependency The requested dependency {@link Object} to be cached.
     * @param <T>        The generic return type of the cached dependency.
     * @return The cached dependency {@link Object}.
     */
    @SuppressWarnings("unchecked")
    protected final <T> T dependency(final Object dependency) {
        if (dependency != null) {

            if (dependency instanceof Scopeable) {
                ((Scopeable) dependency).setScope(this);
            }

            if (dependencyType != null) {
                if (dependencyType.isInstance(dependency)) {
                    return (T) cache(dependencyType, dependency);
                } else {
                    throw new IllegalStateException("The given dependency object is not an instance of: " + dependencyType.getName());
                }
            } else {
                throw new IllegalStateException("The method DependencyScope#dependency(Object) is meant to be used only in method DependencyScope#getDependency()");
            }
        } else {
            throw new IllegalArgumentException("Parameter may not be null");
        }
    }

    /**
     * Caches the given requested dependency {@link Object} using the requested type as a key.
     *
     * @param dependencyType The dependence type as a {@link Class} used as a key.
     * @param dependency     The requested dependency {@link Object} to be cached.
     * @param <T>            The generic return type of the cached dependency.
     * @return The cached dependency {@link Object}.
     */
    @SuppressWarnings("unchecked")
    protected <T> T cache(final Class<T> dependencyType, final Object dependency) {
        if (dependency != null) {
            ArrayList<Object> dependencies = this.dependencies.get(dependencyType);

            if (dependencies == null) {
                dependencies = new ArrayList<>();
                this.dependencies.put(dependencyType, dependencies);
                dependencies.add(dependency);
            } else if (!dependencies.contains(dependency)) {
                dependencies.add(dependency);
            }

            if (dependency instanceof Scopeable) {
                ((Scopeable) dependency).setScope(this);
            }

            if (dependency instanceof DependencyScopeOwner && owner == null) {
                setOwner((DependencyScopeOwner) dependency);
            }

            return (T) dependency;
        } else {
            throw new IllegalArgumentException("Parameter 'dependency' may not be null");
        }
    }

    /**
     * This method is meant to be implemented by each concrete implementation of {@link DependencyScope}.
     * The requested dependency instance is returned by the implementation, if it is capable of providing
     * a such instance. The implementation of this method should not delegate the request to any other
     * {@link DependencyScope}. If the implementation is not able to cache the requested instance,
     * the design contract is to return {@code null} instead.
     *
     * @param <T> A type parameter for casting the requested instance to expected type.
     * @return The requested dependency instance if is this {@link DependencyScope} implementation is
     * capable of providing such instance otherwise {@code null}. This default implementation returns
     * {@code null}.
     */
    protected <T> T getDependency() {
        return null;
    }

    /**
     * Gets an dependency instance of the specified type. The requested dependency is first searched
     * from the currently active {@link DependencyScope}. If a requested instance is not found the search
     * is delegated to parent {@link DependencyScope}. As a last attempt,
     * the {@code AppDependencyScope} is searched.
     *
     * @param dependencyType A {@link Class} specifying the type of the requested instance.
     * @param dependant      The requesting object. This parameter is required when the requesting dependant
     *                       is also a requested within the object graph represented by a {@link DependencyScope}.
     * @param <T>            A type parameter for casting the requested instance to expected type.
     * @param createNew      A {@code boolean} parameter specifying if an instance of the requested
     *                       type should be created using reflection if an instance does not exists already.
     * @return The returned instance. If {@code null} is returned it indicates an error in
     * the implementation of the {@link DependencyScope}.
     */
    @SuppressWarnings("unchecked")
    protected <T> T getDependency(final Class<T> dependencyType, final Object dependant, final boolean createNew) {
        final Class<?> savedDependencyType = this.dependencyType;

        this.dependencyType = dependencyType;

        if (dependant != null) {
            dependants.add(dependant);
        }

        T dependency = null;

        for (final Class<?> key : dependencies.keySet()) {
            if (dependencyType.isAssignableFrom(key)) {
                final ArrayList<T> dependencies = (ArrayList<T>) this.dependencies.get(key);

                if (dependencies != null && !dependencies.isEmpty()) {
                    dependency = dependencies.get(0);
                    break;
                }
            }
        }

        if (dependency == null) {
            dependency = lookDependencyAmongDependants(dependencyType);

            if (dependency == null) {

                if (mockScope != null) {
                    dependency = mockScope.getDependency(dependencyType, dependant, createNew);
                } else {

                    dependency = getDependency();

                    if (dependency == null) {
                        if (getDependencyProvider() != null) {
                            final DependencyQuery<T> query = DependencyQuery.find(dependencyType);
                            dependencyProvider.getDependencies(query);

                            if (query.foundDependencies()) {
                                dependency = query.getFoundDependency();
                            }
                        }
                    }

                    if (dependency != null) {
                        cache(dependencyType, dependency);
                    }
                }

                if (dependency == null) {
                    if (parentScope != null) {
                        dependency = parentScope.getDependency(dependencyType, null, createNew);
                    }

                    if (dependency == null && !isAppScope()) {
                        dependency = Dependency.getAppScope().getDependency(dependencyType, dependant, createNew);
                    }

                    if (dependency == null && createNew) {
                        // As the last resort, try to instantiate the dependency using default constructor

                        try {
                            dependency = dependencyType.newInstance();
                        } catch (Exception e) {
                            Log.d(TAG, "Failed to instantiate object of type: " + dependencyType.getName());
                        }


                        if (dependency != null) {
                            cache(dependencyType, dependency);
                        }
                    }
                }
            }
        }
        this.dependencyType = savedDependencyType;
        return dependency;
    }

    /**
     * Gets an dependency instance of the specified type. The requested dependency is first searched
     * from the currently active {@link DependencyScope}. If a requested instance is not found the search
     * is delegated to parent {@link DependencyScope}. As a last attempt,
     * the {@code AppDependencyScope} is searched.
     *
     * @param query A {@link DependencyQuery} that defines the context for finding dependencies and
     *              a container for storing the found dependencies.
     * @param dependant      The requesting object. This parameter is required when the requesting dependant
     *                       is also a requested within the object graph represented by a {@link DependencyScope}.
     * @param <T>            A type parameter for casting the requested instance to expected type.
     */
    @SuppressWarnings("unchecked")
    protected <T> void getDependencies(final DependencyQuery<T> query, final Object dependant) {

        final Class<?> savedDependencyType = dependencyType;

        dependencyType = query.getDependencyType();

        if (dependant != null) {
            dependants.add(dependant);
        }

        for (final Class<?> key : dependencies.keySet()) {
            if (dependencyType.isAssignableFrom(key)) {
                for (final T dependency : (ArrayList<T>) dependencies.get(key)) {
                    query.add(dependency);
                }
            }
        }

        lookDependenciesAmongDependants(query);

        if (mockScope != null) {
            mockScope.getDependencies(query, dependant);
        } else {
            final T dependency = getDependency();

            if (dependency != null) {
                query.add(dependency); // TODO
            }

            if (getDependencyProvider() != null) {
                dependencyProvider.getDependencies(query);
            }

            if (query.foundDependencies()) {
                for (final T foundDependency : query.getFoundDependencies()) {
                    cache(dependencyType, foundDependency);
                }
            }

            if (parentScope != null) {
                parentScope.getDependencies(query, null);
            }

            if (!isAppScope()) {
                Dependency.getAppScope().getDependencies(query, dependant);
            }
        }
        dependencyType = savedDependencyType;
    }

    /**
     * Checks it the requested dependency is one of the cached dependent instances.
     *
     * @param dependencyType A {@link Class} specifying the type of the requested dependency.
     * @param <T>            A type parameter for casting the requested dependency to expected type.
     * @return The found requested instance or {@code null}.
     */
    @SuppressWarnings("unchecked")
    private <T> T lookDependencyAmongDependants(final Class<T> dependencyType) {

        for (int i = dependants.size() - 1; i >= 0; i--) {
            final Object dependant = dependants.get(i);

            if (dependencyType.isAssignableFrom(dependant.getClass())) {
                dependants.remove(dependant);
                return cache(dependencyType, dependant);
            }
        }
        return null;
    }

    /**
     * Checks it the requested dependency is one of the cached dependent instances.
     *
     * @param query A {@link DependencyQuery}.
     * @param <T>  A type parameter for casting the requested dependency to expected type.
     * @return The found requested instance or {@code null}.
     */
    @SuppressWarnings("unchecked")
    private <T> T lookDependenciesAmongDependants(final DependencyQuery<T> query) {

        for (int i = dependants.size() - 1; i >= 0; i--) {
            final Object dependant = dependants.get(i);

            if (query.isMatchingType(dependant.getClass())) {
                dependants.remove(dependant);
                query.add((T) dependant);
                return cache(query.getDependencyType(), dependant);
            }
        }
        return null;
    }

    /**
     * Disposes this {@link DependencyScope} to support effective GC and to avoid memory leaks.
     */
    protected void dispose() {
        final ArrayList<Object> dependencies = new ArrayList<>();

        for (final ArrayList<Object> dependencySet : this.dependencies.values()) {
            dependencies.addAll(dependencySet);
        }

        for (final Object dependency : dependencies) {
            if (PluginBus.isPlugged(dependency)) {
                PluginBus.unplug(dependency);
            }
        }

        this.dependencies.clear();
        dependants.clear();
        parentScope = null;
        owner = null;
        dependencyType = null;

        if (mockScope != null) {
            mockScope.dispose();
            mockScope = null;
        }
    }

    /**
     * Tests if this {@link DependencyScope} is a application scoped {@link DependencyScope}.
     *
     * @return A {@code boolean},
     */
    public boolean isAppScope() {
        return false;
    }

    /**
     * This method is invoked by {@link Dependency} when this {@link DependencyScope} is activated
     * for the given {@link DependencyScopeOwner}.
     *
     * @param owner A {@link DependencyScopeOwner}.
     */
    @SuppressWarnings("unused")
    public void onActivated(final DependencyScopeOwner owner) {
        // By default do nothing
    }

    /**
     * This method is invoked by {@link Dependency} when this {@link DependencyScope} is deactivated
     * for the given {@link DependencyScopeOwner}.
     *
     * @param owner A {@link DependencyScopeOwner}.
     */
    @SuppressWarnings("unused")
    public void onDeactivated(final DependencyScopeOwner owner) {
        // By default do nothing
    }

    /**
     * Invoked to initialize this {@link DependencyScope}.
     */
    @SuppressWarnings("unchecked")
    public void initialize() {
        if (dependencyProvider == null) {
            initialized = true;

            dependencyProvider = createDependencyProvider();

            if (dependencyProvider == null) {
                final String className = getClass().getName() + DependencyProvider.SUFFIX;

                try {
                    final Class<DependencyProvider> dependencyProviderClass = (Class<DependencyProvider>) Class.forName(className);
                    dependencyProvider = dependencyProviderClass.newInstance();
                    dependencyProvider.setScope(this);
                } catch (Exception e) {
                    Log.d(TAG, "initialize() " + e.getMessage());
                }
            }
        }
    }

    /**
     * This method can be overridden in extending classes to provide a method that explicitly
     * instantiates a {@link DependencyProvider} for this {@link DependencyScope}. By default this
     * method returns {@code null}. If this method returns a {@code null}, then an instance of
     * a {@link DependencyProvider} is attempted to instantiate dynamically.
     *
     * @return A {@link DependencyProvider}. The default implementation returns {@code null}.
     */
    protected DependencyProvider createDependencyProvider() {
        return null;
    }

    /**
     * Removes the given dependency from this {@link DependencyScope}.
     *
     * @param dependency The dependency to be removed as an {@link Object}.
     * @return A {@link List} of removed dependency types for the given dependency.
     */
    public List<Class<?>> removeDependency(final Object dependency) {
        final ArrayList<Class<?>> removedDependencyTypes = new ArrayList<>();

        for (final Class<?> key : dependencies.keySet()) {
            final ArrayList<?> dependencies = this.dependencies.get(key);

            if (dependencies.contains(dependency)) {
                removedDependencyTypes.add(key);
            }
        }

        for (final Class<?> key : removedDependencyTypes) {
            final ArrayList<?> dependencies = this.dependencies.get(key);
            dependencies.remove(dependency);
        }
        dependants.remove(dependency);
        return removedDependencyTypes;
    }

    /**
     * Tests if given dependency exists in this {@link DependencyScope}.
     *
     * @param dependency The dependency as an {@link Object}.
     */
    public boolean hasDependency(final Object dependency) {
        for (final Class<?> key : dependencies.keySet()) {
            final ArrayList<?> dependencies = this.dependencies.get(key);

            if (dependencies.contains(dependency)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Tests if an instance of the specified dependency type exists in this {@link DependencyScope}.
     *
     * @param dependencyType A {@link Class} specifying the dependency type.
     */
    public boolean hasDependency(final Class<?> dependencyType) {
        return dependencies.containsKey(dependencyType) && !dependencies.get(dependencyType).isEmpty();
    }
}
